---
title: [SWEA][D4][JAVA] 동철이의 일 분배
tags: [CodingTest, SWEA]
style: 
color: 
[SWEA][D4][JAVA] 동철이의 일 분배
---

Source: [moeun2](https://github.com/moeun2)



## 풀이방법 (코드에 설명)
```
public class swea_1865_동철이의일분배 {
	static int T, N;
	static double[][] P; //i번 사람이 j번 일을 성공할 확률을 담아놓은 배열
	static boolean[] visited; // 방문배열
	static double success; //모든 일이 성공할 확률
	
	public static void main(String[] args) throws Exception {
		/* input & initialization */
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		T = Integer.parseInt(br.readLine());
		for (int tc = 1; tc <= T; tc++) {
			N = Integer.parseInt(br.readLine()); // 1<=N<=16
			P = new double[N][N];
			visited = new boolean[N];
			success = 0; // 초기화 필수
			for (int i = 0; i < N; i++) {
				st = new StringTokenizer(br.readLine());
				for (int j = 0; j < N; j++) {
					P[i][j] = Double.parseDouble(st.nextToken())/100; //입력부터 미리 /100 해주기
				}
			}

			/* process */
			perm(0, 1); 

			/* output */
			System.out.println("#"+tc +" "+ String.format("%.6f", success * 100));
		}
	
	}
	
	public static void perm(int n, double temp_success) {
		if(n == N) {//직원 번호 == 사람 수 -> 일이 다 배정되었다는 뜻이므로 max를 비교한다.
			success = Math.max(success, temp_success);
			return;
		}
		if(temp_success <= success) { //성공률<1 이므로 곱할수록 작아진므로 작다면 return //가지치기
			return;
		}
		for (int i = 0; i < N; i++) { // 직원 1~n까지 일을 할당한다
			if(!visited[i] && P[n][i] != 0) { // 일이 아직 할당되지 않았고, 성공률이 0이 아니라면
				visited[i] = true; // n(번 직원)에게 i(일)을 할당했음을 표시
				perm(n+1, temp_success * P[n][i]); //(현재까지 성공률 *n이 i했을 때 성공률)을 보내줘 가지치기 할 수 있게 함.
				visited[i] = false; // 그 일을 안할 수 있으니 backtracking
			}
		}
	}
}	
```
## TIL
처음 내가 생각한 방법은 dp or 순열이었다. 사람을 줄 세우고, 일의 순서는 상관이 없다면 전체 값을 계산해서 max 값을 주면 되겠다고 생각하고 기본 순열 방식을 풀었더니 시간 초과가 났다. 15 이상의 수도 있으니 당연했다. 그래서 가지치기를 시도했어야 했는데 곱하면 곱할수록 성공률이 작아진다는 것을 놓쳤었다. 근데 이거 dp로도 풀 수 있을 것 같은데 지금 생각이 안남...arn more!