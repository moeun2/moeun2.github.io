---
title: Python
tags: [Python]
style: border
color: primary
description: I studied the Python and summarized them.
last_modified_at: 19 June 2022
---



# Python TimeComplexity

https://wiki.python.org/moin/TimeComplexity



# 정렬

## Python Documents : Sorting How To

⚡[sortinghowto](https://docs.python.org/ko/3/howto/sorting.html#sortinghowto)

## Syntax

```python
sorted(iterable, key=key, reverse=reverse)
```



## 리스트 요소 길이 순으로 정렬

```python
arr.sort(key=len)
```



## 다중 조건으로 정렬하기

```python
a = [(1, 2), (0, 1), (5, 1), (5, 2), (3, 0)]

# 인자없이 그냥 sorted()만 쓰면, 리스트 아이템의 각 요소 순서대로 정렬을 한다.
b = sorted(a)
# b = [(0, 1), (1, 2), (3, 0), (5, 1), (5, 2)]

# key 인자에 함수를 넘겨주면 해당 함수의 반환값을 비교하여 순서대로 정렬한다.
c = sorted(a, key = lambda x : x[0])
# c = [(0, 1), (1, 2), (3, 0), (5, 1), (5, 2)]
d = sorted(a, key = lambda x : x[1])
# d = [(3, 0), (0, 1), (5, 1), (1, 2), (5, 2)]

# 아이템 첫 번째 인자를 기준으로 오름차순으로 먼저 정렬하고,
# 그리고 그 안에서 다음 두 번째 인자를 기준으로 내림차순으로 정렬하게 하려면, 다음과 같이 할 수 있다.
# -를 붙이면, 현재 정렬차순과 반대로
e = [(1, 3), (0, 3), (1, 4), (1, 5), (0, 1), (2, 4)]
f = sorted(e, key = lambda x : (x[0], -x[1]))
# f = [(0, 3), (0, 1), (1, 5), (1, 4), (1, 3), (2, 4)]
```



# 반올림, 내림, 올림

## 올림

```python
>>> import math
>>> math.ceil(number)    
```

## 내림

```python
>>> import math
>>> math.floor(number)	# math.floor(-3.14) -> -3
>>> math.trunc(number)	# math.floor(-3.14) -> -4
```

- trunc()함수는 내림을 하더라도 0으로 향하는 반면 floor() 함수는 무조건 아래만 향해 내림한다. 

## 반올림

⚡[pythonDocs-round](https://docs.python.org/ko/3/library/functions.html?highlight=round#round)

```python
round(number[, ndigits])
```

- *number* 를 소수점 다음에 *ndigits* 정밀도로 반올림한 값을 돌려줍니다. *ndigits* 가 생략되거나 `None` 이면, 입력에 가장 가까운 정수를 돌려줍니다.

  ex ) 소수점 둘째자리까지 -> round(3.1415, 2) => 3.14


- round()는 사사오입 원칙을 따른다. 반올림할 자리의 수가 5이면 반올림 할 때 앞자리의 숫자가 짝수면 내림하고 홀수면 올림 한다.

# 문자열

## str.join(iterable)

> iterable의 문자열들을 이어 붙인 문자열을 돌려준다.

```python
list = [a,b,c]
#''.join
print(''.join(list)) #abc
# '구분자'.join
print('-.join(list)) #a-b-c
```

# Deque

[collections-deque](https://docs.python.org/ko/3/library/collections.html?highlight=deque#deque-objects)

## Methods 

​	source : [educative](https://www.educative.io/edpresso/how-to-use-a-deque-in-python)

```python
# Import collections module:
import collections

# Initialize deque:
dq = collections.deque([4, 5, 6])

# Append to the right:
dq.append(7)
print("Append 7 to the right: ", list(dq))

# Append to the left:
dq.appendleft(3)
print("Append 3 to the left: ", list(dq))

# Append multiple values to right:
dq.extend([8, 9, 10])
print("Append 8, 9 and 10 to the right: ", list(dq))

# Append multiple values to left:
dq.extendleft([1, 2])
print("Append 2 and 1 to the left: ", list(dq))

# Insert -1 at index 5
dq.insert(5, -1)
print("Insert -1 at index 5: ", list(dq))

# Pop element from the right end:
dq.pop()
print("Remove element from the right: ", list(dq))

# Pop element from the left end:
dq.popleft()
print("Remove element from the left: ", list(dq))

# Remove -1:
dq.remove(-1)
print("Remove -1: ", list(dq))

# Count the number of times 5 occurs:
i = dq.count(5)
print("Count the number of times 5 occurs: ", i)

# Return index of '7' if found between index 4 and 6:
i = dq.index(7, 4, 6)
print("Search index of number 7 between index 4 and 6: ", i)

# Rotate the deque three times to the right:
dq.rotate(3)
print("Rotate the deque 3 times to the right: ", list(dq))

# Reverse the whole deque:
dq.reverse()
print("Reverse the deque: ", list(dq))

```



## Deque Vs. List

Queue로 쓰이는 경우에만 **deque** 가 **list**보다 빠르다. deque는 list처럼 인덱스에 따른 접근이 불가하기 때문에, 중간 갑에 접근하려면 list를 사용하는 것이 더 효율적.

## Deque Vs. Stack

Stack을 사용할 때는 list로 사용하자. 별 차이가 없다. (시간적으로)

## RoundRobin 을 Deque로?
[roundRobin](https://docs.python.org/ko/3/library/collections.html?highlight=deque#deque-objects:~:text=%EB%9D%BC%EC%9A%B4%EB%93%9C%20%EB%A1%9C%EB%B9%88%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC(round%2Drobin%20scheduler)%EB%8A%94%20deque%EC%97%90%20%EC%A0%80%EC%9E%A5%EB%90%9C%20%EC%9E%85%EB%A0%A5%20%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0%EB%A1%9C%20%EA%B5%AC%ED%98%84%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.)



# SET : 집합

## Which is best: remove() vs discard() vs pop()

In a nutshell, all the three functions removes the element from a set but serves best in different scenarios,

1. If you are sure that element to be deleted exists in the set then use the remove() function to delete that element. It is fast because it does not check if the given element exists in the set or not. But it will throw a KeyError in case the element does not exist in the set.
2. If you are not sure that element to be deleted exists in the set or not, then use the discard() function to delete that element. It will not throw any error, if the given element does not exist in the set.
3. If you want to delete a random element from a set and also want to know what is deleted. Then use the pop() function.



# Error

## Dictionary Key error

![image](https://user-images.githubusercontent.com/40678696/179209482-1a3b12e3-44b6-4ac4-b2af-9189bba3371d.png)

key error 이유 : 해당 딕셔너리에 해당 키가 없을 때 일어나는 오류

해당 코드에서는 '1' 이라는 키는 있지만 int형 1의 키는 없음. type 을 잘못 넣어서 생긴 오류