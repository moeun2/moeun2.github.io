---
title: CS Study
tags: [CS]
style: fill
color: warning
description: ⏰ last update 2022/05/28 <br/> This is the CS summary that I studied. I am studying by looking at the document of the reference link below. The PDF summary will continue to be updated.
---

Source: [참고링크](https://github.com/gyoogle/tech-interview-for-developer)



# PDF Summary

💛[Computer Architecture](../assets/CS/컴퓨터의_구조.pdf)
<br/>
💛[Data Structure](../assets/CS/Data_Structure.pdf)
<br/>
💛[Interview](../assets/CS/interview.pdf)

# Summary
## 컴퓨터 구조

###캐시메모리

- 개요 : 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- 장점 : 속도 빠름
- 단점 : 용량 적음, 비용 비쌈
- 작동 원리 : 
  - 시간 지역성(한 번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음), 
  - 공간 지역성(참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음)
- 캐시 미스: 
  - Cold miss(해당 메모리 주소를 처음 불러서 나는 미스)
  - Conflict miss(주소 할당 문제)
  - Capacity miss(공간 문제)

### 패리티 비트 & 해밍코드

- 패리티 비트 : 정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트, 짝수/홀수 패리티 (1의 개수 맞추기)
- 해밍코드 : 오류 검출 뿐만 아니라 오류 수정까지 가능, 2^n 번째 비트가 오류 검출을 위한 패리티 비트
- [예제]([Network] 패리티 비트와 해밍 코드 (tistory.com)


## 운영체제

- 개요 : 시스템의 자원과 동작을 관리하는 소프트웨어
- 목적 : 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축
- 기능 : 자원 관리, 자원의  스케줄링 기능 제공,사용자와 시스템 간의 인터페이스 제공, 하드웨어와 네트워크 관리˙제어, 데이터 및 자원의 공유 기능 제공

<hr>

# Database

## Key - Problems

<details>
<summary>후보키의 조건 2가지</summary>
<div markdown="1">

​	☑️ 2가지 조건 만족 필요

- 유일성 : key로 하나의 Tuple을 유일하게 식별할 수 있음
- 최소성 : 꼭 필요한 속성으로만 구성

</div>

</details>



<details>
<summary>슈퍼키란?</summary>
<div markdown="1">

​	유일성은 만족하지만 최소성은 만족하지 못하는 키

</div>

</details>



<details>
<summary>기본키의 특징 ?</summary>
<div markdown="1">

​	☑️특징

- Null 값을 가질 수 X
- 동일한 값이 중복될 수 X

</div>

</details>

## key

> key : 검색, 정렬 시 tuple을 구분할 수 있는 기준이 되는 Attribute

### Candidate Key(후보키)

> Tuple을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합 -> 기본키로 사용할 수 있는 속성들

​	☑️ 2가지 조건 만족 필요

- 유일성 : key로 하나의 Tuple을 유일하게 식별할 수 있음
- 최소성 : 꼭 필요한 속성으로만 구성

### Primaray Key(기본키)

> 후보키 중 선택한 Main Key

​	☑️특징

- Null 값을 가질 수 X
- 동일한 값이 중복될 수 X

### Alternate Key(대체키)

> 후보키 중 기본키를 제외한 나버지 키 -> 보조키

### Super Key(슈퍼키)

> 유일성은 만족하지만, 최소성은 만족하지 못하는 키

### Foreign Key(외래키)

> 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합



<hr>

# 네트워크

## OSI 7계층

![osi7layer](https://camo.githubusercontent.com/44fe40125073c05a22961a70ae08c4e0b6b2bf5bfbd11f5ab9135e2a683241a7/68747470733a2f2f73373238302e7063646e2e636f2f77702d636f6e74656e742f75706c6f6164732f323031382f30362f6f73692d6d6f64656c2d372d6c61796572732d312e706e67)

![osi7layer/network4layer](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FW8tdG%2Fbtq0iB8I8Ob%2FIk9Cpxufzg6MOyxnkLEkWK%2Fimg.png)

[RestAPI/OSI7Layer/HTTP프로토콜 참고 블로그](https://arclab.tistory.com/120)

### 7계층은 왜 나눌까?

통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이다.

### 1) 물리

> 리피터, 케이블, 허브

​	- 데이터를 전송하는 역할

### 2)데이터 링크

> 브릿지, 스위치 등

​	- 물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할

​	- Mac 주소를 통해 통신한다. 프레임에 Mac 주소를 부여하고 에러검출, 재전송, 흐름제어를 진행한다.

### 3) 네트워크 

> 라우터, IP

​	 - 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당한다.

​	- 라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.

​	- 라우팅, 흐름 제어, 오류 제어, 세그먼테이션 등을 수행한다.

### 4) 전송
> TCP, UDP

​	TCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해준다.

​	- TCP : 신뢰성, 연결지향적

​	- UDP : 비신뢰성, 비연결성, 실시간

### 5) 세션
> RPC, Socket
> ​	- 데이터가 통신하기 위한 논리적 연결을 담당한다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있다.

### 6) 표현
> JPEG, MPEG 등
> ​	- 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다.

​	- 파일 인코딩, 명령어를 포장, 압축 암호화한다.

### 7) 응용
> HTTP, FTP, DNS 등
> ​	- 최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.

​	- 사용자 인터페이스, 전자우현, 데이터베이스 관리 등의 서비를 제공한다.



## TCP | 3 way handshake & 4 way handshake

### 3 way handshake - **연결 성립**

![3 way handshake](https://camo.githubusercontent.com/4acea6af95884347810f057d00c6c4643a56d4a7dbbdf49740745560cd45cc1f/68747470733a2f2f6d656469612e6765656b73666f726765656b732e6f72672f77702d636f6e74656e742f75706c6f6164732f5443502d636f6e6e656374696f6e2d312e706e67)

1. 클라이언트가 서버에게 SYN 패킷을 보냄 (sequence : x)
2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (sequence : y, ACK : x + 1)
3. 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄

### 4 way handshake - **연결 해제**

![4 way handshake](https://camo.githubusercontent.com/8bb8960e46a3bfada6a237a7a91bce75a0a3e0e34eab5c1f5143ca6fe34d0b5f/68747470733a2f2f6d656469612e6765656b73666f726765656b732e6f72672f77702d636f6e74656e742f75706c6f6164732f434e2e706e67)

1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.
2. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)
3. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.
4. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.)

- 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed)
- TIME_WAIT 시간이 끝나면 클라이언트도 닫는다 (Closed)